---
title: 2019年11月14日 日报 
teaser: 十多天的努力
tags: [markdown, workflow, foss]
---
## Servlet
	线程安全问题:
	Servlet的service方法,每次被请求时,调用.
	这个调用很特殊,是在新的子线程中调用的,当service方法执行完毕,子线程死亡了.
	可以简单的理解为:service方法每次执行都是一个新的线程.
	同步代码块:synchronized(锁对象){代码}
	锁对象:锁对象必须写在公有的地方并且如果是new对象只能是一个共同的不能不能不断的new,就是说只能有一把锁,如果每次都new一个就会造成一个人一把锁的现象
	静态同步方法是 类名.class
	普通方法是:this

	请求转发
	概念:一个web组件将未处理完毕的请求,通过tomcat转交给另一个web组件处理

	步骤:
	1.获取转发器:
	RequestDispatcher rd= request.getRequestDispatcher("转发的地址");
	2.通过转发器,发起转发
	rd.forward(request,response)
	简写步骤:
	request.getRequestDispatcher("转发地址").forward(request,response)
	转发流程:
	1.当浏览器访问服务器tomcat时
	2.tomcat将请求信息与相应工具进行封装,传递给我们的Servlet的service方法进行处理
	3.我们在service方法中,得到请求转发器,通过请求转发器告知tomcat,请求转发的地址.
	4.tomcat接收到请求转发需求,会重新封装请求信息,将请求对象与相应对象传递给转发地址的servlet的service方法进行处理
	特点:
	1.转发过程中,多个servlet之间共享一分请求信息,共享一个相应对象.
	2.转发只能发生在同一个服务器中.(转发无法实现跨域(域名))
	3.无论转发发生多少次,对于浏览器来说,浏览器只发起过一次请求,并且只接到了一次响应.
	4.相对于重定向来说,效率更高.
	请求重定向
	概念:响应时告知浏览器新的请求地址,浏览器接收到后,自动请求新的地址!

	步骤:
	response.sendRedirect("重定向地址");
	重定向流程:
	1.当客户端访问服务器时,服务器对浏览器响应一个302的状态码以及一个location的地址
	2.HTTP协议约定,当浏览器接受到302状态码时,会自动寻找location地址,并发起新的请求
	(相当于控制用户浏览器自动完成了页面的跳转)
	特点:
	1.重定向会产生新的请求,和新的响应.
	2.使用重定向可以实现跨域操作也就是说可以在多个服务器之间发生
	3.浏览器地址栏的内容会发生改变
	4.相对于请求转发而言,效率较低
	转发和重定向注意点:
	1.在一次用户的操作中可以无限的转发和重定向,但是记住:一定要存在出口
	2.当servlet中的请求已经被转发或重定向后,在此servlet后续的代码中不能进行响应








